package com.example.demo.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Column;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Enumerated;
import jakarta.persistence.EnumType;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.LocalDateTime;
import java.time.Duration;

@Entity
@Table(name = "generated_shift_schedule")
public class GeneratedShiftSchedule {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "shift_date", nullable = false)
    private LocalDate shiftDate;
    
    @Column(name = "start_time", nullable = false)
    private LocalTime startTime;
    
    @Column(name = "end_time", nullable = false)
    private LocalTime endTime;
    
    @ManyToOne
    @JoinColumn(name = "shift_template_id")
    private ShiftTemplate shiftTemplate;
    
    @ManyToOne
    @JoinColumn(name = "department_id", nullable = false)
    private Department department;
    
    @ManyToOne
    @JoinColumn(name = "employee_id", nullable = false)
    private Employee employee;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ShiftStatus status = ShiftStatus.SCHEDULED;
    
    // Actual worked hours (filled after shift completion)
    @Column(name = "actual_start_time")
    private LocalTime actualStartTime;
    
    @Column(name = "actual_end_time")
    private LocalTime actualEndTime;
    
    @Column(name = "notes")
    private String notes;
    
    @Column(name = "auto_generated", nullable = false)
    private Boolean autoGenerated = true;
    
    // Enum for shift status
    public enum ShiftStatus {
        SCHEDULED,
        IN_PROGRESS,
        COMPLETED,
        CANCELLED,
        NO_SHOW,
        REASSIGNED
    }
    
    // Constructors
    public GeneratedShiftSchedule() {
    }
    
    // Constructor for auto-generated shifts
    public GeneratedShiftSchedule(LocalDate shiftDate, LocalTime startTime, LocalTime endTime,
                                 ShiftTemplate shiftTemplate, Department department, Employee employee) {
        this.shiftDate = shiftDate;
        this.startTime = startTime;
        this.endTime = endTime;
        this.shiftTemplate = shiftTemplate;
        this.department = department;
        this.employee = employee;
        this.autoGenerated = true;
    }
    
    // Constructor for manual shifts
    public GeneratedShiftSchedule(LocalDate shiftDate, LocalTime startTime, LocalTime endTime,
                                 Department department, Employee employee) {
        this.shiftDate = shiftDate;
        this.startTime = startTime;
        this.endTime = endTime;
        this.department = department;
        this.employee = employee;
        this.autoGenerated = false;
    }
    
    // Getters and Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public LocalDate getShiftDate() {
        return shiftDate;
    }
    
    public void setShiftDate(LocalDate shiftDate) {
        this.shiftDate = shiftDate;
    }
    
    public LocalTime getStartTime() {
        return startTime;
    }
    
    public void setStartTime(LocalTime startTime) {
        this.startTime = startTime;
    }
    
    public LocalTime getEndTime() {
        return endTime;
    }
    
    public void setEndTime(LocalTime endTime) {
        this.endTime = endTime;
    }
    
    public ShiftTemplate getShiftTemplate() {
        return shiftTemplate;
    }
    
    public void setShiftTemplate(ShiftTemplate shiftTemplate) {
        this.shiftTemplate = shiftTemplate;
    }
    
    public Department getDepartment() {
        return department;
    }
    
    public void setDepartment(Department department) {
        this.department = department;
    }
    
    public Employee getEmployee() {
        return employee;
    }
    
    public void setEmployee(Employee employee) {
        this.employee = employee;
    }
    
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
    
    public ShiftStatus getStatus() {
        return status;
    }
    
    public void setStatus(ShiftStatus status) {
        this.status = status;
    }
    
    public LocalTime getActualStartTime() {
        return actualStartTime;
    }
    
    public void setActualStartTime(LocalTime actualStartTime) {
        this.actualStartTime = actualStartTime;
    }
    
    public LocalTime getActualEndTime() {
        return actualEndTime;
    }
    
    public void setActualEndTime(LocalTime actualEndTime) {
        this.actualEndTime = actualEndTime;
    }
    
    public String getNotes() {
        return notes;
    }
    
    public void setNotes(String notes) {
        this.notes = notes;
    }
    
    public Boolean getAutoGenerated() {
        return autoGenerated;
    }
    
    public void setAutoGenerated(Boolean autoGenerated) {
        this.autoGenerated = autoGenerated;
    }
    
    // Lifecycle callbacks
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        validateShift();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
        validateShift();
    }
    
    // Validation method
    private void validateShift() {
        // Validate times
        if (startTime != null && endTime != null && !endTime.isAfter(startTime)) {
            throw new IllegalArgumentException("endTime must be after startTime");
        }
        
        // Validate date not in past for new schedules
        if (shiftDate != null && shiftDate.isBefore(LocalDate.now())) {
            throw new IllegalArgumentException("Cannot schedule shifts in the past");
        }

        if (shiftDate == null || startTime == null || endTime == null) {
            throw new IllegalArgumentException("shiftDate, startTime, and endTime are required");
        }
        
        if (department == null) {
            throw new IllegalArgumentException("department is required");
        }
        
        if (employee == null) {
            throw new IllegalArgumentException("employee is required");
        }
    }
    
    public double getPlannedDurationHours() {
        if (startTime == null || endTime == null) {
            return 0.0;
        }
        
        if (endTime.isBefore(startTime)) {
            return (24.0 - startTime.toSecondOfDay() / 3600.0) + 
                   (endTime.toSecondOfDay() / 3600.0);
        }
        
        return (endTime.toSecondOfDay() - startTime.toSecondOfDay()) / 3600.0;
    }
    
    public double getActualDurationHours() {
        if (actualStartTime == null || actualEndTime == null) {
            return 0.0;
        }
        
        if (actualEndTime.isBefore(actualStartTime)) {
            return (24.0 - actualStartTime.toSecondOfDay() / 3600.0) + 
                   (actualEndTime.toSecondOfDay() / 3600.0);
        }
        
        return (actualEndTime.toSecondOfDay() - actualStartTime.toSecondOfDay()) / 3600.0;
    }
    
    public boolean isToday() {
        return shiftDate != null && shiftDate.isEqual(LocalDate.now());
    }
    
    public boolean isPastShift() {
        return shiftDate != null && shiftDate.isBefore(LocalDate.now());
    }
    
    public boolean isFutureShift() {
        return shiftDate != null && shiftDate.isAfter(LocalDate.now());
    }
    

    public boolean isCurrentlyActive() {
        if (!isToday()) {
            return false;
        }
        
        LocalTime now = LocalTime.now();
        return (startTime != null && endTime != null) && 
               !now.isBefore(startTime) && !now.isAfter(endTime);
    }
    
    public boolean isCompleted() {
        return status == ShiftStatus.COMPLETED;
    }
    
    public boolean canStart() {
        return status == ShiftStatus.SCHEDULED && isToday() && 
               startTime != null && LocalTime.now().isAfter(startTime.minusMinutes(15));
    }
    
    public boolean canComplete() {
        return status == ShiftStatus.IN_PROGRESS;
    }
    
    public boolean employeeHasRequiredSkills() {
        if (shiftTemplate != null && shiftTemplate.getRequiredSkills() != null) {
            String requiredSkills = shiftTemplate.getRequiredSkills();
            String employeeSkills = employee.getSkills();
            
            if (requiredSkills != null && employeeSkills != null) {
                String[] requiredSkillArray = requiredSkills.split(",");
                String[] employeeSkillArray = employeeSkills.split(",");
                
                for (String requiredSkill : requiredSkillArray) {
                    boolean found = false;
                    for (String employeeSkill : employeeSkillArray) {
                        if (employeeSkill.trim().equalsIgnoreCase(requiredSkill.trim())) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        return false;
                    }
                }
                return true;
            }
        }
        return true;
    }
    
    public void startShift() {
        if (!canStart()) {
            throw new IllegalStateException("Shift cannot be started");
        }
        this.status = ShiftStatus.IN_PROGRESS;
        this.actualStartTime = LocalTime.now();
    }
    
    public void completeShift() {
        if (!canComplete()) {
            throw new IllegalStateException("Shift cannot be completed");
        }
        this.status = ShiftStatus.COMPLETED;
        this.actualEndTime = LocalTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    public void cancelShift(String reason) {
        if (isCompleted()) {
            throw new IllegalStateException("Cannot cancel completed shift");
        }
        this.status = ShiftStatus.CANCELLED;
        this.notes = (this.notes != null ? this.notes + "\nCancelled: " : "Cancelled: ") + reason;
        this.updatedAt = LocalDateTime.now();
    }
    
    @Override
    public String toString() {
        return "GeneratedShiftSchedule{" +
                "id=" + id +
                ", shiftDate=" + shiftDate +
                ", startTime=" + startTime +
                ", endTime=" + endTime +
                ", shiftTemplate=" + (shiftTemplate != null ? shiftTemplate.getTemplateName() : "null") +
                ", department=" + (department != null ? department.getName() : "null") +
                ", employee=" + (employee != null ? employee.getFullName() : "null") +
                ", status=" + status +
                ", autoGenerated=" + autoGenerated +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
}